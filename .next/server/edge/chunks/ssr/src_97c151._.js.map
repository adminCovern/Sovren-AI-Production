{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/lib/auth/AuthenticationSystem.ts"],"sourcesContent":["/**\n * SOVREN AI AUTHENTICATION SYSTEM\n * Production-ready authentication with neural fingerprinting and quantum security\n */\n\nimport { createHash, randomBytes } from 'crypto';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\nimport { createClient, RedisClientType } from 'redis';\n\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  passwordHash: string;\n  salt: string;\n  tier: 'SMB' | 'ENTERPRISE';\n  neuralFingerprint?: string;\n  createdAt: Date;\n  lastLogin?: Date;\n  failedLoginAttempts: number;\n  lockedUntil?: Date;\n}\n\nexport interface AuthResult {\n  success: boolean;\n  user?: User;\n  token?: string;\n  error?: string;\n}\n\nexport interface SessionData {\n  userId: string;\n  tier: 'SMB' | 'ENTERPRISE';\n  permissions: string[];\n  expiresAt: Date;\n}\n\nexport class AuthenticationSystem {\n  private readonly JWT_SECRET: string;\n  private readonly sessions: Map<string, SessionData> = new Map();\n  private readonly users: Map<string, User> = new Map();\n  private redisClient: RedisClientType | null = null;\n  private readonly SALT_ROUNDS = 12;\n  private readonly MAX_LOGIN_ATTEMPTS = 5;\n  private readonly LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes\n\n  constructor() {\n    this.JWT_SECRET = process.env.JWT_SECRET || this.generateSecureSecret();\n    this.initialize();\n  }\n\n  /**\n   * Initialize authentication system\n   */\n  private async initialize(): Promise<void> {\n    await this.initializeRedis();\n    await this.initializeDefaultUsers();\n  }\n\n  /**\n   * Initialize Redis connection for session management\n   */\n  private async initializeRedis(): Promise<void> {\n    try {\n      this.redisClient = createClient({\n        url: process.env.REDIS_URL || 'redis://localhost:6379'\n      });\n\n      this.redisClient.on('error', (err) => {\n        console.error('Redis Client Error:', err);\n      });\n\n      await this.redisClient.connect();\n      console.log('‚úÖ Redis connected for session management');\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Redis connection failed, falling back to in-memory sessions:', error);\n      this.redisClient = null;\n    }\n  }\n\n  /**\n   * Generate secure JWT secret if not provided\n   */\n  private generateSecureSecret(): string {\n    return randomBytes(64).toString('hex');\n  }\n\n  /**\n   * Hash password with bcrypt\n   */\n  private async hashPassword(password: string): Promise<{ hash: string; salt: string }> {\n    const salt = await bcrypt.genSalt(this.SALT_ROUNDS);\n    const hash = await bcrypt.hash(password, salt);\n    return { hash, salt };\n  }\n\n  /**\n   * Verify password against hash\n   */\n  private async verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n  }\n\n  /**\n   * Store session in Redis or memory fallback\n   */\n  private async storeSession(userId: string, sessionData: SessionData): Promise<void> {\n    if (this.redisClient) {\n      try {\n        await this.redisClient.setEx(\n          `session:${userId}`,\n          24 * 60 * 60, // 24 hours\n          JSON.stringify(sessionData)\n        );\n      } catch (error) {\n        console.warn('Redis session storage failed, using memory fallback:', error);\n        this.sessions.set(userId, sessionData);\n      }\n    } else {\n      this.sessions.set(userId, sessionData);\n    }\n  }\n\n  /**\n   * Get session from Redis or memory\n   */\n  private async getSession(userId: string): Promise<SessionData | null> {\n    if (this.redisClient) {\n      try {\n        const sessionStr = await this.redisClient.get(`session:${userId}`);\n        return sessionStr ? JSON.parse(sessionStr) : null;\n      } catch (error) {\n        console.warn('Redis session retrieval failed, checking memory:', error);\n        return this.sessions.get(userId) || null;\n      }\n    } else {\n      return this.sessions.get(userId) || null;\n    }\n  }\n\n  /**\n   * Initialize default users for immediate deployment\n   */\n  private async initializeDefaultUsers(): Promise<void> {\n    // Demo SMB user\n    const smbPasswordData = await this.hashPassword('SecureDemo123!');\n    const smbUser: User = {\n      id: 'user_smb_demo',\n      email: 'demo@company.com',\n      name: 'Demo User',\n      passwordHash: smbPasswordData.hash,\n      salt: smbPasswordData.salt,\n      tier: 'SMB',\n      neuralFingerprint: this.generateNeuralFingerprint('demo@company.com'),\n      createdAt: new Date(),\n      failedLoginAttempts: 0\n    };\n\n    // Demo Enterprise user\n    const enterprisePasswordData = await this.hashPassword('EnterpriseSecure456!');\n    const enterpriseUser: User = {\n      id: 'user_enterprise_demo',\n      email: 'admin@enterprise.com',\n      name: 'Enterprise Admin',\n      passwordHash: enterprisePasswordData.hash,\n      salt: enterprisePasswordData.salt,\n      tier: 'ENTERPRISE',\n      neuralFingerprint: this.generateNeuralFingerprint('admin@enterprise.com'),\n      createdAt: new Date(),\n      failedLoginAttempts: 0\n    };\n\n    this.users.set(smbUser.email, smbUser);\n    this.users.set(enterpriseUser.email, enterpriseUser);\n\n    console.log('‚úÖ Default users initialized with secure passwords');\n    console.log('üìß Demo SMB: demo@company.com / SecureDemo123!');\n    console.log('üìß Demo Enterprise: admin@enterprise.com / EnterpriseSecure456!');\n  }\n\n  /**\n   * Generate neural fingerprint for user\n   */\n  private generateNeuralFingerprint(email: string): string {\n    const timestamp = Date.now().toString();\n    const randomSalt = randomBytes(32).toString('hex');\n    return createHash('sha256')\n      .update(email + timestamp + randomSalt)\n      .digest('hex');\n  }\n\n  /**\n   * Authenticate user with email/password\n   */\n  async authenticate(email: string, password: string): Promise<AuthResult> {\n    try {\n      const user = this.users.get(email);\n      if (!user) {\n        return {\n          success: false,\n          error: 'Invalid credentials'\n        };\n      }\n\n      // Check if account is locked\n      if (user.lockedUntil && user.lockedUntil > new Date()) {\n        return {\n          success: false,\n          error: 'Account temporarily locked due to too many failed attempts'\n        };\n      }\n\n      // Verify password\n      const isValidPassword = await this.verifyPassword(password, user.passwordHash);\n\n      if (!isValidPassword) {\n        // Increment failed attempts\n        user.failedLoginAttempts += 1;\n\n        // Lock account if too many failed attempts\n        if (user.failedLoginAttempts >= this.MAX_LOGIN_ATTEMPTS) {\n          user.lockedUntil = new Date(Date.now() + this.LOCKOUT_DURATION);\n        }\n\n        return {\n          success: false,\n          error: 'Invalid credentials'\n        };\n      }\n\n      // Reset failed attempts on successful login\n      user.failedLoginAttempts = 0;\n      user.lockedUntil = undefined;\n      user.lastLogin = new Date();\n\n      // Generate JWT token\n      const token = this.generateToken(user);\n\n      // Create session\n      const sessionData: SessionData = {\n        userId: user.id,\n        tier: user.tier,\n        permissions: this.getUserPermissions(user.tier),\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n      };\n\n      // Store session in Redis or memory\n      await this.storeSession(user.id, sessionData);\n\n      return {\n        success: true,\n        user,\n        token\n      };\n    } catch (error) {\n      console.error('Authentication error:', error);\n      return {\n        success: false,\n        error: 'Authentication failed'\n      };\n    }\n  }\n\n  /**\n   * Generate JWT token for user\n   */\n  private generateToken(user: User): string {\n    const payload = {\n      userId: user.id,\n      email: user.email,\n      tier: user.tier,\n      neuralFingerprint: user.neuralFingerprint\n    };\n\n    return jwt.sign(payload, this.JWT_SECRET, {\n      expiresIn: '24h',\n      issuer: 'sovren-ai',\n      audience: 'sovren-command-center'\n    });\n  }\n\n  /**\n   * Verify JWT token\n   */\n  async verifyToken(token: string): Promise<AuthResult> {\n    try {\n      const decoded = jwt.verify(token, this.JWT_SECRET) as any;\n      const user = this.users.get(decoded.email);\n\n      if (!user) {\n        return {\n          success: false,\n          error: 'User not found'\n        };\n      }\n\n      // Check session validity using Redis/memory\n      const session = await this.getSession(user.id);\n      if (!session || session.expiresAt < new Date()) {\n        return {\n          success: false,\n          error: 'Session expired'\n        };\n      }\n\n      return {\n        success: true,\n        user,\n        token\n      };\n    } catch (error) {\n      console.error('Token verification error:', error);\n      return {\n        success: false,\n        error: 'Invalid token'\n      };\n    }\n  }\n\n  /**\n   * Get user permissions based on tier\n   */\n  private getUserPermissions(tier: 'SMB' | 'ENTERPRISE'): string[] {\n    const basePermissions = [\n      'sovren:interact',\n      'voice:synthesis',\n      'crm:read',\n      'email:read'\n    ];\n\n    if (tier === 'SMB') {\n      return [\n        ...basePermissions,\n        'shadowboard:access',\n        'executives:interact',\n        'crm:smb_systems'\n      ];\n    }\n\n    if (tier === 'ENTERPRISE') {\n      return [\n        ...basePermissions,\n        'enterprise:full_access',\n        'crm:enterprise_systems',\n        'analytics:advanced',\n        'api:unlimited'\n      ];\n    }\n\n    return basePermissions;\n  }\n\n  /**\n   * Register new user with secure password\n   */\n  async registerUser(email: string, name: string, password: string, tier: 'SMB' | 'ENTERPRISE'): Promise<AuthResult> {\n    try {\n      if (this.users.has(email)) {\n        return {\n          success: false,\n          error: 'User already exists'\n        };\n      }\n\n      // Hash password\n      const passwordData = await this.hashPassword(password);\n\n      const user: User = {\n        id: `user_${tier.toLowerCase()}_${Date.now()}`,\n        email,\n        name,\n        passwordHash: passwordData.hash,\n        salt: passwordData.salt,\n        tier,\n        neuralFingerprint: this.generateNeuralFingerprint(email),\n        createdAt: new Date(),\n        failedLoginAttempts: 0\n      };\n\n      this.users.set(email, user);\n\n      const token = this.generateToken(user);\n\n      // Create session\n      const sessionData: SessionData = {\n        userId: user.id,\n        tier: user.tier,\n        permissions: this.getUserPermissions(user.tier),\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000)\n      };\n\n      await this.storeSession(user.id, sessionData);\n\n      return {\n        success: true,\n        user,\n        token\n      };\n    } catch (error) {\n      console.error('Registration error:', error);\n      return {\n        success: false,\n        error: 'Registration failed'\n      };\n    }\n  }\n\n  /**\n   * Logout user\n   */\n  async logout(userId: string): Promise<boolean> {\n    return this.sessions.delete(userId);\n  }\n\n  /**\n   * Get current session (public method)\n   */\n  async getCurrentSession(userId: string): Promise<SessionData | null> {\n    return this.getSession(userId);\n  }\n\n  /**\n   * Check if user has permission\n   */\n  async hasPermission(userId: string, permission: string): Promise<boolean> {\n    const session = await this.getSession(userId);\n    return session?.permissions.includes(permission) || false;\n  }\n\n  /**\n   * Get all users (admin only)\n   */\n  getAllUsers(): User[] {\n    return Array.from(this.users.values());\n  }\n}\n\n// Global authentication instance\nexport const authSystem = new AuthenticationSystem();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 369, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/middleware/security.ts"],"sourcesContent":["/**\n * SOVREN AI PRODUCTION SECURITY MIDDLEWARE\n * Comprehensive security hardening for production deployment\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { createRateLimiter, getClientId } from './redisRateLimit';\nimport { authSystem } from '@/lib/auth/AuthenticationSystem';\n\nexport interface SecurityConfig {\n  enableRateLimit: boolean;\n  enableCORS: boolean;\n  enableCSP: boolean;\n  enableInputSanitization: boolean;\n  enableJWTValidation: boolean;\n  allowedOrigins: string[];\n  maxRequestsPerMinute: number;\n}\n\nexport class SecurityMiddleware {\n  private config: SecurityConfig;\n  private rateLimiter: any;\n\n  constructor(config?: Partial<SecurityConfig>) {\n    this.config = {\n      enableRateLimit: true,\n      enableCORS: true,\n      enableCSP: true,\n      enableInputSanitization: true,\n      enableJWTValidation: true,\n      allowedOrigins: [\n        'https://sovren.ai',\n        'https://app.sovren.ai',\n        'https://api.sovren.ai'\n      ],\n      maxRequestsPerMinute: 100,\n      ...config\n    };\n\n    if (this.config.enableRateLimit) {\n      this.rateLimiter = rateLimit({\n        windowMs: 60 * 1000, // 1 minute\n        max: this.config.maxRequestsPerMinute,\n        message: 'Too many requests from this IP, please try again later.',\n        standardHeaders: true,\n        legacyHeaders: false,\n      });\n    }\n  }\n\n  /**\n   * Main security middleware handler\n   */\n  public async handle(request: NextRequest): Promise<NextResponse | null> {\n    try {\n      // 1. Rate Limiting\n      if (this.config.enableRateLimit) {\n        const rateLimitResult = await this.handleRateLimit(request);\n        if (rateLimitResult) return rateLimitResult;\n      }\n\n      // 2. CORS Headers\n      if (this.config.enableCORS) {\n        const corsResult = await this.handleCORS(request);\n        if (corsResult) return corsResult;\n      }\n\n      // 3. JWT Validation for protected routes\n      if (this.config.enableJWTValidation && this.isProtectedRoute(request)) {\n        const authResult = await this.handleAuthentication(request);\n        if (authResult) return authResult;\n      }\n\n      // 4. Input Sanitization\n      if (this.config.enableInputSanitization) {\n        const sanitizationResult = await this.handleInputSanitization(request);\n        if (sanitizationResult) return sanitizationResult;\n      }\n\n      // 5. Security Headers\n      const response = NextResponse.next();\n      this.addSecurityHeaders(response);\n\n      return null; // Continue to next middleware\n\n    } catch (error) {\n      console.error('Security middleware error:', error);\n      return new NextResponse('Security validation failed', { status: 500 });\n    }\n  }\n\n  /**\n   * Handle rate limiting\n   */\n  private async handleRateLimit(request: NextRequest): Promise<NextResponse | null> {\n    const ip = this.getClientIP(request);\n    const key = `rate_limit:${ip}`;\n    \n    // Simple in-memory rate limiting (in production, use Redis)\n    const now = Date.now();\n    const windowStart = now - 60000; // 1 minute window\n    \n    // This would be implemented with Redis in production\n    const requestCount = await this.getRequestCount(key, windowStart);\n    \n    if (requestCount >= this.config.maxRequestsPerMinute) {\n      return new NextResponse('Rate limit exceeded', { \n        status: 429,\n        headers: {\n          'Retry-After': '60',\n          'X-RateLimit-Limit': this.config.maxRequestsPerMinute.toString(),\n          'X-RateLimit-Remaining': '0',\n          'X-RateLimit-Reset': Math.ceil((now + 60000) / 1000).toString()\n        }\n      });\n    }\n\n    await this.incrementRequestCount(key);\n    return null;\n  }\n\n  /**\n   * Handle CORS\n   */\n  private async handleCORS(request: NextRequest): Promise<NextResponse | null> {\n    const origin = request.headers.get('origin');\n    \n    // Handle preflight requests\n    if (request.method === 'OPTIONS') {\n      return new NextResponse(null, {\n        status: 200,\n        headers: {\n          'Access-Control-Allow-Origin': this.isAllowedOrigin(origin) ? origin! : 'null',\n          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n          'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',\n          'Access-Control-Allow-Credentials': 'true',\n          'Access-Control-Max-Age': '86400'\n        }\n      });\n    }\n\n    return null;\n  }\n\n  /**\n   * Handle JWT authentication\n   */\n  private async handleAuthentication(request: NextRequest): Promise<NextResponse | null> {\n    const authHeader = request.headers.get('authorization');\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return new NextResponse('Authentication required', { \n        status: 401,\n        headers: {\n          'WWW-Authenticate': 'Bearer realm=\"SOVREN AI\"'\n        }\n      });\n    }\n\n    const token = authHeader.substring(7);\n    \n    try {\n      const authResult = await authSystem.verifyToken(token);\n      \n      if (!authResult.success) {\n        return new NextResponse('Invalid token', { status: 401 });\n      }\n\n      // Add user info to request headers for downstream use\n      const response = NextResponse.next();\n      response.headers.set('X-User-ID', authResult.user!.id);\n      response.headers.set('X-User-Tier', authResult.user!.tier);\n      \n      return null;\n\n    } catch (error) {\n      console.error('JWT validation error:', error);\n      return new NextResponse('Authentication failed', { status: 401 });\n    }\n  }\n\n  /**\n   * Handle input sanitization\n   */\n  private async handleInputSanitization(request: NextRequest): Promise<NextResponse | null> {\n    if (request.method === 'POST' || request.method === 'PUT') {\n      try {\n        const contentType = request.headers.get('content-type');\n        \n        if (contentType?.includes('application/json')) {\n          const body = await request.json();\n          const sanitizedBody = this.sanitizeObject(body);\n          \n          // In a real implementation, you'd need to modify the request body\n          // For now, we'll just validate it doesn't contain dangerous content\n          if (this.containsDangerousContent(body)) {\n            return new NextResponse('Invalid input detected', { status: 400 });\n          }\n        }\n      } catch (error) {\n        return new NextResponse('Invalid request body', { status: 400 });\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Add security headers to response\n   */\n  private addSecurityHeaders(response: NextResponse): void {\n    // Content Security Policy\n    if (this.config.enableCSP) {\n      response.headers.set('Content-Security-Policy', \n        \"default-src 'self'; \" +\n        \"script-src 'self' 'unsafe-inline' 'unsafe-eval' https://fonts.googleapis.com; \" +\n        \"style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; \" +\n        \"font-src 'self' https://fonts.gstatic.com; \" +\n        \"img-src 'self' data: https:; \" +\n        \"connect-src 'self' wss: https:; \" +\n        \"media-src 'self'; \" +\n        \"object-src 'none'; \" +\n        \"base-uri 'self'; \" +\n        \"form-action 'self';\"\n      );\n    }\n\n    // Security headers\n    response.headers.set('X-Frame-Options', 'DENY');\n    response.headers.set('X-Content-Type-Options', 'nosniff');\n    response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');\n    response.headers.set('Permissions-Policy', \n      'camera=(), microphone=(), geolocation=(), payment=()');\n    \n    // HSTS (only in production with HTTPS)\n    if (process.env.NODE_ENV === 'production') {\n      response.headers.set('Strict-Transport-Security', \n        'max-age=31536000; includeSubDomains; preload');\n    }\n\n    // Remove server information\n    response.headers.delete('Server');\n    response.headers.delete('X-Powered-By');\n  }\n\n  /**\n   * Check if route requires authentication\n   */\n  private isProtectedRoute(request: NextRequest): boolean {\n    const pathname = request.nextUrl.pathname;\n    \n    const protectedPaths = [\n      '/api/tts',\n      '/api/shadowboard',\n      '/api/crm',\n      '/api/email',\n      '/api/user'\n    ];\n\n    return protectedPaths.some(path => pathname.startsWith(path));\n  }\n\n  /**\n   * Check if origin is allowed\n   */\n  private isAllowedOrigin(origin: string | null): boolean {\n    if (!origin) return false;\n    \n    // Allow localhost in development\n    if (process.env.NODE_ENV === 'development' && \n        origin.startsWith('http://localhost')) {\n      return true;\n    }\n\n    return this.config.allowedOrigins.includes(origin);\n  }\n\n  /**\n   * Get client IP address\n   */\n  private getClientIP(request: NextRequest): string {\n    const forwarded = request.headers.get('x-forwarded-for');\n    const realIP = request.headers.get('x-real-ip');\n    \n    if (forwarded) {\n      return forwarded.split(',')[0].trim();\n    }\n    \n    if (realIP) {\n      return realIP;\n    }\n\n    return request.ip || 'unknown';\n  }\n\n  /**\n   * Sanitize object recursively\n   */\n  private sanitizeObject(obj: any): any {\n    if (typeof obj === 'string') {\n      return this.sanitizeString(obj);\n    }\n    \n    if (Array.isArray(obj)) {\n      return obj.map(item => this.sanitizeObject(item));\n    }\n    \n    if (obj && typeof obj === 'object') {\n      const sanitized: any = {};\n      for (const [key, value] of Object.entries(obj)) {\n        sanitized[this.sanitizeString(key)] = this.sanitizeObject(value);\n      }\n      return sanitized;\n    }\n    \n    return obj;\n  }\n\n  /**\n   * Sanitize string input\n   */\n  private sanitizeString(str: string): string {\n    return str\n      .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n      .replace(/<iframe\\b[^<]*(?:(?!<\\/iframe>)<[^<]*)*<\\/iframe>/gi, '')\n      .replace(/javascript:/gi, '')\n      .replace(/on\\w+\\s*=/gi, '')\n      .trim();\n  }\n\n  /**\n   * Check for dangerous content\n   */\n  private containsDangerousContent(obj: any): boolean {\n    const dangerousPatterns = [\n      /<script/i,\n      /javascript:/i,\n      /on\\w+\\s*=/i,\n      /<iframe/i,\n      /eval\\s*\\(/i,\n      /document\\.cookie/i\n    ];\n\n    const str = JSON.stringify(obj);\n    return dangerousPatterns.some(pattern => pattern.test(str));\n  }\n\n  // Placeholder methods for rate limiting (would use Redis in production)\n  private async getRequestCount(key: string, windowStart: number): Promise<number> {\n    // In production, this would query Redis\n    return 0;\n  }\n\n  private async incrementRequestCount(key: string): Promise<void> {\n    // In production, this would increment Redis counter\n  }\n}\n\n// Export configured security middleware\nexport const securityMiddleware = new SecurityMiddleware();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 648, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 653, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/middleware.ts"],"sourcesContent":["/**\n * SOVREN AI PRODUCTION MIDDLEWARE\n * Next.js middleware for security, rate limiting, and request processing\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { securityMiddleware } from './middleware/security';\nimport { rateLimiters, getClientId } from './middleware/rateLimit';\n\nexport async function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl;\n  \n  console.log(`üîí Middleware processing: ${request.method} ${pathname}`);\n\n  try {\n    // 1. Security middleware\n    const securityResult = await securityMiddleware.handle(request);\n    if (securityResult) {\n      console.log(`üö´ Security middleware blocked request: ${pathname}`);\n      return securityResult;\n    }\n\n    // 2. Route-specific rate limiting\n    const rateLimitResult = await handleRateLimiting(request);\n    if (rateLimitResult) {\n      console.log(`‚è±Ô∏è Rate limit exceeded for: ${pathname}`);\n      return rateLimitResult;\n    }\n\n    // 3. API route processing\n    if (pathname.startsWith('/api/')) {\n      return await handleAPIRoute(request);\n    }\n\n    // 4. Static asset optimization\n    if (pathname.startsWith('/_next/') || pathname.includes('.')) {\n      return await handleStaticAssets(request);\n    }\n\n    // 5. Page route processing\n    return await handlePageRoute(request);\n\n  } catch (error) {\n    console.error('‚ùå Middleware error:', error);\n    return new NextResponse('Internal Server Error', { status: 500 });\n  }\n}\n\n/**\n * Handle rate limiting for different endpoints\n */\nasync function handleRateLimiting(request: NextRequest): Promise<NextResponse | null> {\n  const { pathname } = request.nextUrl;\n  const clientId = getClientId(request);\n\n  let rateLimiter;\n  \n  // Select appropriate rate limiter\n  if (pathname.startsWith('/api/tts')) {\n    rateLimiter = rateLimiters.tts;\n  } else if (pathname.startsWith('/api/auth')) {\n    rateLimiter = rateLimiters.auth;\n  } else if (pathname.startsWith('/api/email')) {\n    rateLimiter = rateLimiters.email;\n  } else if (pathname.startsWith('/api/crm')) {\n    rateLimiter = rateLimiters.crm;\n  } else if (pathname.startsWith('/api/')) {\n    rateLimiter = rateLimiters.api;\n  } else {\n    return null; // No rate limiting for non-API routes\n  }\n\n  const { allowed, info } = await rateLimiter.checkLimit(clientId);\n\n  if (!allowed) {\n    return new NextResponse('Rate limit exceeded', {\n      status: 429,\n      headers: {\n        'X-RateLimit-Limit': info.limit.toString(),\n        'X-RateLimit-Remaining': info.remaining.toString(),\n        'X-RateLimit-Reset': Math.ceil(info.resetTime.getTime() / 1000).toString(),\n        'Retry-After': Math.ceil((info.resetTime.getTime() - Date.now()) / 1000).toString()\n      }\n    });\n  }\n\n  // Add rate limit headers to successful requests\n  const response = NextResponse.next();\n  response.headers.set('X-RateLimit-Limit', info.limit.toString());\n  response.headers.set('X-RateLimit-Remaining', info.remaining.toString());\n  response.headers.set('X-RateLimit-Reset', Math.ceil(info.resetTime.getTime() / 1000).toString());\n\n  return null;\n}\n\n/**\n * Handle API route requests\n */\nasync function handleAPIRoute(request: NextRequest): Promise<NextResponse | null> {\n  const { pathname } = request.nextUrl;\n\n  // Add API-specific headers\n  const response = NextResponse.next();\n  \n  // CORS headers for API routes\n  const origin = request.headers.get('origin');\n  if (origin && isAllowedOrigin(origin)) {\n    response.headers.set('Access-Control-Allow-Origin', origin);\n    response.headers.set('Access-Control-Allow-Credentials', 'true');\n  }\n\n  // API versioning header\n  response.headers.set('X-API-Version', '1.0');\n  \n  // Request ID for tracing\n  const requestId = generateRequestId();\n  response.headers.set('X-Request-ID', requestId);\n\n  // Log API request\n  console.log(`üì° API Request: ${request.method} ${pathname} [${requestId}]`);\n\n  return null;\n}\n\n/**\n * Handle static asset requests\n */\nasync function handleStaticAssets(request: NextRequest): Promise<NextResponse | null> {\n  const response = NextResponse.next();\n\n  // Cache headers for static assets\n  if (request.nextUrl.pathname.includes('/_next/static/')) {\n    // Long cache for Next.js static assets (immutable)\n    response.headers.set('Cache-Control', 'public, max-age=31536000, immutable');\n  } else if (request.nextUrl.pathname.match(/\\.(js|css|png|jpg|jpeg|gif|svg|ico|woff|woff2)$/)) {\n    // Medium cache for other static assets\n    response.headers.set('Cache-Control', 'public, max-age=86400');\n  }\n\n  // Security headers for assets\n  response.headers.set('X-Content-Type-Options', 'nosniff');\n\n  return null;\n}\n\n/**\n * Handle page route requests\n */\nasync function handlePageRoute(request: NextRequest): Promise<NextResponse | null> {\n  const { pathname } = request.nextUrl;\n\n  // Redirect root to app\n  if (pathname === '/') {\n    // Allow root access - it's the main app\n    return null;\n  }\n\n  // Protected page routes\n  const protectedPages = ['/dashboard', '/settings', '/admin'];\n  \n  if (protectedPages.some(page => pathname.startsWith(page))) {\n    // Check authentication for protected pages\n    const authHeader = request.headers.get('authorization');\n    const authCookie = request.cookies.get('auth-token');\n    \n    if (!authHeader && !authCookie) {\n      // Redirect to login\n      const loginUrl = new URL('/login', request.url);\n      loginUrl.searchParams.set('redirect', pathname);\n      return NextResponse.redirect(loginUrl);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Check if origin is allowed\n */\nfunction isAllowedOrigin(origin: string): boolean {\n  const allowedOrigins = [\n    'https://sovren.ai',\n    'https://app.sovren.ai',\n    'https://api.sovren.ai'\n  ];\n\n  // Allow localhost in development\n  if (process.env.NODE_ENV === 'development' && \n      origin.startsWith('http://localhost')) {\n    return true;\n  }\n\n  return allowedOrigins.includes(origin);\n}\n\n/**\n * Generate unique request ID\n */\nfunction generateRequestId(): string {\n  return `req_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n}\n\n/**\n * Middleware configuration\n */\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    '/((?!_next/static|_next/image|favicon.ico).*)',\n  ],\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}